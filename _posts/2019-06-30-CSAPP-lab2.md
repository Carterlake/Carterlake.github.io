####phase1：

我们从asm.txt 里找到phase_1,我们可以看到在这个函数调用了（strings not equal）函数，从名字推测是比较输入字符串和密码的，在进入比较函数前，我们可以看到push了一个立即数，我们在gdb里查看这个地址的内容。

 

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image002.gif)

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image004.gif)

发现一串字符串，显然这个就是phase的密码。

 

 

 

输入这个字符串，通过关卡一。

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image006.gif)

 

 

 

 

 

 

 

 

####Phase2:

进入关卡二，我们再看到asm的phase_2，我们先扫一遍，emmm，（read_six_number）还能有更明显的提示吗，看起来第二关密码是六个数字。

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image008.gif)

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image010.gif)

 

好吧，我们进入read函数里查看一下，前面的操作是为调用系统函数scanf作准备，其中一个参数是0x804a223中的字符串

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image012.gif)

 

 

 

可以看到这里需要输入六个整型数,并且后面检测了数字的数量，小于5就会炸，六个数字分别储存在eax和edx以及edx的几个偏移地址

 

 

我们回到phase2里接着往下看

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image014.gif)这里出现了一个立即数的比较，并且比较错了就会炸，这显然是一个线索

 

 

 

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image016.gif)

如果比较正确，这个地址里的数就会交给ebx，并转到0x8048ba4，我们调到这个地址查看

 

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image018.gif)这里的操作是先将ebx里的数交给eax，eax变为原来的两倍，在与ebx中后一个数比较。如果不相等就爆炸

那其实到这里思路就很明朗了，输入六个数字，第一个数是1，后面的每个数是前面的两倍，即 密码为1 2 4 8 16 32

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image020.gif)

 

 

 

输入密码正确

 

 

 

####Phase3:

我们继续查看phase3的代码：

 

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image022.gif)

我们看到这里的输入函数是系统函数scanf，并且其中一个参数是0x804a0aa中的字符串，我们在gdb中查看这个地址

 

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image024.gif)

 

 

 

看起来这一关的密码是 数字+字符+数字

我们接着往下看：

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image026.gif)

 

首先当然不能错过任何一个cmp，这里对eax进行了一个比较，大于2就会炸，我们从上面的代码中知道eax储存了第一个整型数。即第一个数可能是0，1或者负数。

 

往下看。第一个数小于2时

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image028.gif)前面两个指令没太弄懂，推测是长度大于等于7爆炸（限制字符数量），第三条指令，跳转到（0x804a0c0）+4*eax的指令，我们知道，eax是第一个输入的数，那么这里就是一个分支跳转，跳转和第一个输入的数有关。

当eax = 0 时，我们在gdb中查看0x804a0c0，

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image030.gif)

 

 

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image032.gif)

我们跳到0x0848c1d看一看

 

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image033.gif)后面是几段相似的代码，应该就是分支的不同跳转，从0x8048c1d开始看，将77赋给了eax，0x8（%esp）应该是输入的第三个数，当它为0x283（643）时，跳到0x8048d18，

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image035.gif)第二个字符和al即此时的0x77相比，则第二个数应该为0x77对应的字符

综上所述，密码的其中一个为  0  w 643

输入密码，通过第三关

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image037.gif)

 

 

 

 

 

####Phase4

我们继续phase4

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image039.gif)

 

 

前期依然是scanf函数的调用，我们查看0x804a22f

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image041.gif)

 

 

这一次的密码是两个整型数

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image043.gif)

后面如果eax小于就爆炸，这个是第二个数的输入限制

 

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image045.gif)

后面一段是为func4调用作准备

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image047.gif)func4 的解析看图片里的注释，总的来说，这是一个递归调用，输入a = phase4输入的第二个数字，b = 前面准备的 push 0x7，返回参数为eax，

fun4（b） = （a + func（b-1）+func（b-2）），func（1） = a， func(b<=0) = 0;

当起始参数b = 7时，eax = func（7） = 33a；

 

 

好了，解析完func4，我们回到phase_4看，

 

 

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image049.gif)可以看到 eax 和0x8（%esp）比较，不等就炸，在gdb里查看，这个地址存的是输入的第一个数字。

再往下看

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image051.gif)这里的0x4（%esp）是输入的第二个数，即x2-2<=2,x2<=4，

好了，到这里phase4解析完，密码也出来了，x1 = 33*x2， 2=<x2<=4.

即66 2； 99 3 ； 132 4 都可以

这里只截取66 2的结果图

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image053.gif)

 

 

 

 

 

 

####phase5

进入phase5

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image055.gif)

前期是调用了string_length函数，我们看看这个函数是干了什么

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image057.gif)string_length函数做的就是计算输入字符的长度并存在eax里

回到phase5往后看

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image059.gif)这里可以看到输入字符长度是6，

 

 

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image061.gif)

这一段解析需要在gdb里不停查看寄存器，不多赘述，解析请看注释

 

总的来说，这里对输入字符串的每一位进行处理，并根据处理后的数据找到一个地址，我们查看一下这个地址后面的内容

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image063.gif)从0x804a0e0开始，每四位一个数字，取10个数字出来方便后续查看，2 10 6 1 12 16 9 3 4 7

 

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image065.gif)后面的操作是，六个数字处理后找到六个地址里的数加起来等于51

对照上面的数字表，我们可以分解为51 = 16 +12+10+10+1+2

对应位置数字是5 4 1 1 3 0，这里答案不一定并且数字顺序可以随意换

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image067.gif)后面就是结束函数

那么我们这里得到的密码就是541130

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image069.gif)

 

 

通关成功

 

 

 

 

 

 

 

####phase6

phase6的分析非常复杂

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image071.gif)这一段直接说结果，这里调用了read_six_number,读入了六个数字，后续的一系列比较做的是检测保证输入为1-6且不重复，否则爆炸。

 

后面一段代码，解析请看注释，这一段代码做的是检测每个输入的数字并根据数字得到一个地址，这里得到六个地址0x804c178(只有后三位不一样，其他的是16c,13c,154,160,148)，我们查看一个地址，发现是一个叫node的数据结构，猜测是链表的节点。

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image073.gif)用命令输出六个节点

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image075.gif)发现node的结构应该如下所示

 

**struct {**

​    **int value;**

​    **int order;**

​    **node\* next;**

**} node;**

按这种形式，我们记节点为（360,1），34a,2）,(17d,3),(78,4),(ab,5),(373,6)

 

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image077.gif)

 

 

 

 

 

 

 

 

 

 

后面这一段是按照输入的顺序查看节点，并比较这个顺序的节点中Value值是否为降序，不是则爆炸，是则通关，

 

（360,1），34a,2）,(17d,3),(78,4),(ab,5),(373,6)

由我们得到的六个节点，按value的降序排列得到结果为6 1 2 3 5 4，炸弹拆除

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image079.gif)

 

 

 

**六个密码为：**

 

**All your base are belong to us.**

**1 2 4 8 16 32**

**0 w 643**

**66 2**

**541130**

**6 1 2 3 5 4**

**其中第三、四、五关答案不唯一。**

 

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image081.gif)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

**SecretPhase**

其实还有个隐藏关，但是太复杂了，总的思路是二叉树的递归运算

开启隐藏关的方式为第四关后面加一个字符串“DrEvil”并且前六关都通过,

这里直接给结论，

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image083.gif)

func7翻译成c语言如下所示：

Int Fun7(node* addr, int input){

 

​       If(addr==null)  return -1;

 

​       If(*addr <= input){

 

​       If(*addr == input ) return 0;

 

​       Else 2*fun7(addr+8,input)+1;

 

}

 

Else 2*fun7(addr+4,input);

![img](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image085.gif)

}

我们需要这个函数返回3，

返回值为3，那么它肯定是根据 2*1+1得到的，也就是说下一层的fun返回值为1；

 

​       返回值为1，那么肯定是2*0+1得到，也即是说下一层fun返回值为0；

 